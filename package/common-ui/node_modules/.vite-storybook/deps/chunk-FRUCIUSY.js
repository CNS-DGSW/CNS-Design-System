import {
  require_is_regexp
} from "./chunk-SK7S7JOK.js";
import {
  require_regexp_get_flags,
  require_regexp_sticky_helpers,
  require_regexp_unsupported_dot_all,
  require_regexp_unsupported_ncg
} from "./chunk-OLVSTUBD.js";
import {
  require_inherit_if_required,
  require_to_string
} from "./chunk-KSWJJUVF.js";
import {
  require_create_non_enumerable_property,
  require_define_built_in,
  require_descriptors,
  require_fails,
  require_function_uncurry_this,
  require_global,
  require_has_own_property,
  require_internal_state,
  require_is_forced,
  require_object_define_property,
  require_object_get_own_property_names,
  require_object_is_prototype_of,
  require_set_species,
  require_well_known_symbol
} from "./chunk-JUVUO6NV.js";
import {
  __commonJS
} from "./chunk-TFWDKVI3.js";

// ../../.yarn/unplugged/core-js-npm-3.29.1-baa30db121/node_modules/core-js/internals/proxy-accessor.js
var require_proxy_accessor = __commonJS({
  "../../.yarn/unplugged/core-js-npm-3.29.1-baa30db121/node_modules/core-js/internals/proxy-accessor.js"(exports, module) {
    var defineProperty = require_object_define_property().f;
    module.exports = function(Target, Source, key) {
      key in Target || defineProperty(Target, key, {
        configurable: true,
        get: function() {
          return Source[key];
        },
        set: function(it) {
          Source[key] = it;
        }
      });
    };
  }
});

// ../../.yarn/unplugged/core-js-npm-3.29.1-baa30db121/node_modules/core-js/modules/es.regexp.constructor.js
var DESCRIPTORS = require_descriptors();
var global = require_global();
var uncurryThis = require_function_uncurry_this();
var isForced = require_is_forced();
var inheritIfRequired = require_inherit_if_required();
var createNonEnumerableProperty = require_create_non_enumerable_property();
var getOwnPropertyNames = require_object_get_own_property_names().f;
var isPrototypeOf = require_object_is_prototype_of();
var isRegExp = require_is_regexp();
var toString = require_to_string();
var getRegExpFlags = require_regexp_get_flags();
var stickyHelpers = require_regexp_sticky_helpers();
var proxyAccessor = require_proxy_accessor();
var defineBuiltIn = require_define_built_in();
var fails = require_fails();
var hasOwn = require_has_own_property();
var enforceInternalState = require_internal_state().enforce;
var setSpecies = require_set_species();
var wellKnownSymbol = require_well_known_symbol();
var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
var MATCH = wellKnownSymbol("match");
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var SyntaxError = global.SyntaxError;
var exec = uncurryThis(RegExpPrototype.exec);
var charAt = uncurryThis("".charAt);
var replace = uncurryThis("".replace);
var stringIndexOf = uncurryThis("".indexOf);
var stringSlice = uncurryThis("".slice);
var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
var re1 = /a/g;
var re2 = /a/g;
var CORRECT_NEW = new NativeRegExp(re1) !== re1;
var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function() {
  re2[MATCH] = false;
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, "i") != "/a/i";
}));
var handleDotAll = function(string) {
  var length = string.length;
  var index = 0;
  var result = "";
  var brackets = false;
  var chr;
  for (; index <= length; index++) {
    chr = charAt(string, index);
    if (chr === "\\") {
      result += chr + charAt(string, ++index);
      continue;
    }
    if (!brackets && chr === ".") {
      result += "[\\s\\S]";
    } else {
      if (chr === "[") {
        brackets = true;
      } else if (chr === "]") {
        brackets = false;
      }
      result += chr;
    }
  }
  return result;
};
var handleNCG = function(string) {
  var length = string.length;
  var index = 0;
  var result = "";
  var named = [];
  var names = {};
  var brackets = false;
  var ncg = false;
  var groupid = 0;
  var groupname = "";
  var chr;
  for (; index <= length; index++) {
    chr = charAt(string, index);
    if (chr === "\\") {
      chr = chr + charAt(string, ++index);
    } else if (chr === "]") {
      brackets = false;
    } else if (!brackets)
      switch (true) {
        case chr === "[":
          brackets = true;
          break;
        case chr === "(":
          if (exec(IS_NCG, stringSlice(string, index + 1))) {
            index += 2;
            ncg = true;
          }
          result += chr;
          groupid++;
          continue;
        case (chr === ">" && ncg):
          if (groupname === "" || hasOwn(names, groupname)) {
            throw new SyntaxError("Invalid capture group name");
          }
          names[groupname] = true;
          named[named.length] = [groupname, groupid];
          ncg = false;
          groupname = "";
          continue;
      }
    if (ncg)
      groupname += chr;
    else
      result += chr;
  }
  return [result, named];
};
if (isForced("RegExp", BASE_FORCED)) {
  RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === void 0;
    var groups = [];
    var rawPattern = pattern;
    var rawFlags, dotAll, sticky, handled, result, state;
    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
      return pattern;
    }
    if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
      pattern = pattern.source;
      if (flagsAreUndefined)
        flags = getRegExpFlags(rawPattern);
    }
    pattern = pattern === void 0 ? "" : toString(pattern);
    flags = flags === void 0 ? "" : toString(flags);
    rawPattern = pattern;
    if (UNSUPPORTED_DOT_ALL && "dotAll" in re1) {
      dotAll = !!flags && stringIndexOf(flags, "s") > -1;
      if (dotAll)
        flags = replace(flags, /s/g, "");
    }
    rawFlags = flags;
    if (MISSED_STICKY && "sticky" in re1) {
      sticky = !!flags && stringIndexOf(flags, "y") > -1;
      if (sticky && UNSUPPORTED_Y)
        flags = replace(flags, /y/g, "");
    }
    if (UNSUPPORTED_NCG) {
      handled = handleNCG(pattern);
      pattern = handled[0];
      groups = handled[1];
    }
    result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
    if (dotAll || sticky || groups.length) {
      state = enforceInternalState(result);
      if (dotAll) {
        state.dotAll = true;
        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
      }
      if (sticky)
        state.sticky = true;
      if (groups.length)
        state.groups = groups;
    }
    if (pattern !== rawPattern)
      try {
        createNonEnumerableProperty(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
      } catch (error) {
      }
    return result;
  };
  for (keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index; ) {
    proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
  }
  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  defineBuiltIn(global, "RegExp", RegExpWrapper, { constructor: true });
}
var RegExpWrapper;
var keys;
var index;
setSpecies("RegExp");
//# sourceMappingURL=chunk-FRUCIUSY.js.map
