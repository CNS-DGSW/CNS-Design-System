import {
  STORY_RENDERED
} from "./chunk-I5FJA7UU.js";
import {
  esm_default2 as esm_default
} from "./chunk-CW55F7I7.js";
import {
  logger,
  require_es_regexp_exec
} from "./chunk-OLVSTUBD.js";
import {
  require_es_array_iterator,
  require_es_string_iterator,
  require_window
} from "./chunk-KSWJJUVF.js";
import {
  __toESM
} from "./chunk-TFWDKVI3.js";

// ../../.yarn/__virtual__/@storybook-addons-virtual-d579c7de5f/0/cache/@storybook-addons-npm-6.5.16-f82ac7ef6c-0463150e4c.zip/node_modules/@storybook/addons/dist/esm/index.js
var import_global = __toESM(require_window());

// ../../.yarn/__virtual__/@storybook-addons-virtual-d579c7de5f/0/cache/@storybook-addons-npm-6.5.16-f82ac7ef6c-0463150e4c.zip/node_modules/@storybook/addons/dist/esm/storybook-channel-mock.js
function mockChannel() {
  var transport = {
    setHandler: function setHandler() {
    },
    send: function send() {
    }
  };
  return new esm_default({
    transport
  });
}

// ../../.yarn/__virtual__/@storybook-addons-virtual-d579c7de5f/0/cache/@storybook-addons-npm-6.5.16-f82ac7ef6c-0463150e4c.zip/node_modules/@storybook/addons/dist/esm/types.js
var types;
(function(types2) {
  types2["TAB"] = "tab";
  types2["PANEL"] = "panel";
  types2["TOOL"] = "tool";
  types2["TOOLEXTRA"] = "toolextra";
  types2["PREVIEW"] = "preview";
  types2["NOTES_ELEMENT"] = "notes-element";
})(types || (types = {}));

// ../../.yarn/__virtual__/@storybook-addons-virtual-d579c7de5f/0/cache/@storybook-addons-npm-6.5.16-f82ac7ef6c-0463150e4c.zip/node_modules/@storybook/addons/dist/esm/index.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var AddonStore = _createClass(function AddonStore2() {
  var _this = this;
  _classCallCheck(this, AddonStore2);
  this.loaders = {};
  this.elements = {};
  this.config = {};
  this.channel = void 0;
  this.serverChannel = void 0;
  this.promise = void 0;
  this.resolve = void 0;
  this.getChannel = function() {
    if (!_this.channel) {
      _this.setChannel(mockChannel());
    }
    return _this.channel;
  };
  this.getServerChannel = function() {
    if (!_this.serverChannel) {
      throw new Error("Accessing non-existent serverChannel");
    }
    return _this.serverChannel;
  };
  this.ready = function() {
    return _this.promise;
  };
  this.hasChannel = function() {
    return !!_this.channel;
  };
  this.hasServerChannel = function() {
    return !!_this.serverChannel;
  };
  this.setChannel = function(channel) {
    _this.channel = channel;
    _this.resolve();
  };
  this.setServerChannel = function(channel) {
    _this.serverChannel = channel;
  };
  this.getElements = function(type) {
    if (!_this.elements[type]) {
      _this.elements[type] = {};
    }
    return _this.elements[type];
  };
  this.addPanel = function(name, options) {
    _this.add(name, Object.assign({
      type: types.PANEL
    }, options));
  };
  this.add = function(name, addon) {
    var type = addon.type;
    var collection = _this.getElements(type);
    collection[name] = Object.assign({
      id: name
    }, addon);
  };
  this.setConfig = function(value) {
    Object.assign(_this.config, value);
  };
  this.getConfig = function() {
    return _this.config;
  };
  this.register = function(name, registerCallback) {
    if (_this.loaders[name]) {
      logger.warn("".concat(name, " was loaded twice, this could have bad side-effects"));
    }
    _this.loaders[name] = registerCallback;
  };
  this.loadAddons = function(api) {
    Object.values(_this.loaders).forEach(function(value) {
      return value(api);
    });
  };
  this.promise = new Promise(function(res) {
    _this.resolve = function() {
      return res(_this.getChannel());
    };
  });
});
var KEY = "__STORYBOOK_ADDONS";
function getAddonsStore() {
  if (!import_global.default[KEY]) {
    import_global.default[KEY] = new AddonStore();
  }
  return import_global.default[KEY];
}
var addons = getAddonsStore();

// ../../.yarn/__virtual__/@storybook-addons-virtual-d579c7de5f/0/cache/@storybook-addons-npm-6.5.16-f82ac7ef6c-0463150e4c.zip/node_modules/@storybook/addons/dist/esm/hooks.js
var import_es_array_iterator = __toESM(require_es_array_iterator());
var import_es_string_iterator = __toESM(require_es_string_iterator());
var import_es_regexp_exec = __toESM(require_es_regexp_exec());
var import_global2 = __toESM(require_window());
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var globalWindow = import_global2.default.window;
var HooksContext = function() {
  function HooksContext2() {
    var _this = this;
    _classCallCheck2(this, HooksContext2);
    this.hookListsMap = void 0;
    this.mountedDecorators = void 0;
    this.prevMountedDecorators = void 0;
    this.currentHooks = void 0;
    this.nextHookIndex = void 0;
    this.currentPhase = void 0;
    this.currentEffects = void 0;
    this.prevEffects = void 0;
    this.currentDecoratorName = void 0;
    this.hasUpdates = void 0;
    this.currentContext = void 0;
    this.renderListener = function(storyId) {
      if (storyId !== _this.currentContext.id)
        return;
      _this.triggerEffects();
      _this.currentContext = null;
      _this.removeRenderListeners();
    };
    this.init();
  }
  _createClass2(HooksContext2, [{
    key: "init",
    value: function init() {
      this.hookListsMap = /* @__PURE__ */ new WeakMap();
      this.mountedDecorators = /* @__PURE__ */ new Set();
      this.prevMountedDecorators = this.mountedDecorators;
      this.currentHooks = [];
      this.nextHookIndex = 0;
      this.currentPhase = "NONE";
      this.currentEffects = [];
      this.prevEffects = [];
      this.currentDecoratorName = null;
      this.hasUpdates = false;
      this.currentContext = null;
    }
  }, {
    key: "clean",
    value: function clean() {
      this.prevEffects.forEach(function(effect) {
        if (effect.destroy) {
          effect.destroy();
        }
      });
      this.init();
      this.removeRenderListeners();
    }
  }, {
    key: "getNextHook",
    value: function getNextHook() {
      var hook = this.currentHooks[this.nextHookIndex];
      this.nextHookIndex += 1;
      return hook;
    }
  }, {
    key: "triggerEffects",
    value: function triggerEffects() {
      var _this2 = this;
      this.prevEffects.forEach(function(effect) {
        if (!_this2.currentEffects.includes(effect) && effect.destroy) {
          effect.destroy();
        }
      });
      this.currentEffects.forEach(function(effect) {
        if (!_this2.prevEffects.includes(effect)) {
          effect.destroy = effect.create();
        }
      });
      this.prevEffects = this.currentEffects;
      this.currentEffects = [];
    }
  }, {
    key: "addRenderListeners",
    value: function addRenderListeners() {
      this.removeRenderListeners();
      var channel = addons.getChannel();
      channel.on(STORY_RENDERED, this.renderListener);
    }
  }, {
    key: "removeRenderListeners",
    value: function removeRenderListeners() {
      var channel = addons.getChannel();
      channel.removeListener(STORY_RENDERED, this.renderListener);
    }
  }]);
  return HooksContext2;
}();
function hookify(fn) {
  return function() {
    var _ref = typeof (arguments.length <= 0 ? void 0 : arguments[0]) === "function" ? arguments.length <= 1 ? void 0 : arguments[1] : arguments.length <= 0 ? void 0 : arguments[0], hooks = _ref.hooks;
    var prevPhase = hooks.currentPhase;
    var prevHooks = hooks.currentHooks;
    var prevNextHookIndex = hooks.nextHookIndex;
    var prevDecoratorName = hooks.currentDecoratorName;
    hooks.currentDecoratorName = fn.name;
    if (hooks.prevMountedDecorators.has(fn)) {
      hooks.currentPhase = "UPDATE";
      hooks.currentHooks = hooks.hookListsMap.get(fn) || [];
    } else {
      hooks.currentPhase = "MOUNT";
      hooks.currentHooks = [];
      hooks.hookListsMap.set(fn, hooks.currentHooks);
      hooks.prevMountedDecorators.add(fn);
    }
    hooks.nextHookIndex = 0;
    var prevContext = globalWindow.STORYBOOK_HOOKS_CONTEXT;
    globalWindow.STORYBOOK_HOOKS_CONTEXT = hooks;
    var result = fn.apply(void 0, arguments);
    globalWindow.STORYBOOK_HOOKS_CONTEXT = prevContext;
    if (hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null) {
      throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
    }
    hooks.currentPhase = prevPhase;
    hooks.currentHooks = prevHooks;
    hooks.nextHookIndex = prevNextHookIndex;
    hooks.currentDecoratorName = prevDecoratorName;
    return result;
  };
}
var numberOfRenders = 0;
var RENDER_LIMIT = 25;
var applyHooks = function applyHooks2(applyDecorators) {
  return function(storyFn, decorators) {
    var decorated = applyDecorators(hookify(storyFn), decorators.map(function(decorator) {
      return hookify(decorator);
    }));
    return function(context) {
      var _ref2 = context, hooks = _ref2.hooks;
      hooks.prevMountedDecorators = hooks.mountedDecorators;
      hooks.mountedDecorators = new Set([storyFn].concat(_toConsumableArray(decorators)));
      hooks.currentContext = context;
      hooks.hasUpdates = false;
      var result = decorated(context);
      numberOfRenders = 1;
      while (hooks.hasUpdates) {
        hooks.hasUpdates = false;
        hooks.currentEffects = [];
        result = decorated(context);
        numberOfRenders += 1;
        if (numberOfRenders > RENDER_LIMIT) {
          throw new Error("Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.");
        }
      }
      hooks.addRenderListeners();
      return result;
    };
  };
};

export {
  addons,
  HooksContext,
  applyHooks
};
//# sourceMappingURL=chunk-6JISW2SI.js.map
